from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
import os
import subprocess
import uvicorn
from fastapi import Request
import aiohttp

app = FastAPI()

# Enable Cross-Origin Resource Sharing (CORS)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

DOWNLOAD_DIR = "downloaded-files"
os.makedirs(DOWNLOAD_DIR, exist_ok=True)


# Endpoint to download files
@app.get("/download/{file_name}")
async def download_file(file_name: str):
    safe_filename = os.path.basename(file_name)
    file_path = os.path.join(DOWNLOAD_DIR, safe_filename)

    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")

    return FileResponse(
        file_path, filename=safe_filename, media_type="application/octet-stream"
    )


# Endpoint to download a file from a URL and save it locally
@app.post("/fetch-file")
async def fetch_file(url: str, file_name: str = None):
    """
    Downloads a file from a given URL and saves it to the local directory.
    \n\n
    Args:\n
        \turl (str): The URL of the file to download.
    \n\n
    Returns:\n
        \tdict: A dictionary containing the status of the operation and the saved file name.
    \n\n
    Raises:\n
        \tHTTPException: If the URL is invalid or the download fails, an HTTP 400 or 500 error is raised.
    """
    try:
        if not url:
            raise HTTPException(status_code=400, detail="URL is required")

        file_name = os.path.basename(url) if file_name is None else file_name
        file_path = os.path.join(DOWNLOAD_DIR, file_name)

        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status != 200:
                    raise HTTPException(
                        status_code=500, detail="Failed to download the file"
                    )
                with open(file_path, "wb") as f:
                    f.write(await response.read())

        return {"status": "success", "file_name": file_name}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Endpoint to run a Makefile command
@app.post("/reweb")
async def reweb(target: str = "file"):
    """
    Executes a Makefile command asynchronously using the specified target.
    \n\n
    Args:\n
        \ttarget (str): The Makefile target to execute. Defaults to "file".
                      This parameter will appear as an option in FastAPI's
                      autogenerated documentation.
    \n\n
    Returns:\n
        \tdict: A dictionary containing the status of the operation and a success message.
    \n\n
    Raises:\n
        \tHTTPException: If the Makefile command fails, an HTTP 500 error is raised with the error details.
    \n\n
    Note:\n
        \tTo ensure the `target` parameter appears as an option in FastAPI's documentation,\n
        \tit is defined as a function argument with a default value.\n
        \tThe command options: [fomrat, web, backend, file, web-end, restart, restart-web]\n
    """
    try:
        subprocess.Popen(
            ["make", target], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        return {
            "status": "success",
            "output": f"Makefile command '{target}' executed successfully.",
        }
    except subprocess.CalledProcessError as e:
        raise HTTPException(
            status_code=500, detail=f"Makefile command failed: {e.stderr}"
        )


# Run the server with host="0.0.0.0" for Codespaces
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
